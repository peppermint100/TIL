## 시간복잡도

- 해당 자료구조의 시간 효율성의 척도.

- 책장 안의 책을 정렬하여 꽂아두면 나중에 원하는 책을 빠르게 찾을 수 있다.

## 공간복잡도

- 해당 자료구조의 공간 효율성의 척도.
- 테트리스처럼 여러가지 모양의 블록을 공간 활용을 잘하여 잘 맞게 배치하면 같은 공간에 더 많은 양의 블록이 들어간다.

### 1부터 n까지의 연속한 숫자를 더한 값을 구하는 알고리즘

```python
def sum_n(n):
    s = 0
    i = 0
    for i in range(0, n):
        i = i+1
        s = s + i
    return s

def sum_n2(n):
    return n*(n+1)/2


print(sum_n(100))
print(sum_n2(100))
```

위와 같이 같은 입력에 같은 결과를 내는 함수에도 효율이 다르다. sum_n의 경우는 입력 파라미터인 n의 값이 커질 수록 반복문에 의한 계산을 여러번 해야 하지만 sum_n2의 경우는 단 한번의 계산만을 거치면 된다. 이는 가우스의 방식을 이용한 함수이다.

## 빅오 표기법

어떤 알고리즘이 문제를 풀기 위해서 어느정도의 시간적 공간적 비용이 드는지 시간 복잡도, 공간 복잡도를 통해 나타낼 수 있다. 이러한 시간 복잡도, 공간 복잡도를 나타내는 방법의 가장 대표적인 예가 빅오 표기법에 해당한다.(이 외에도 세타와 오메가가 있다. 이들을 점근 표기법이라고 한다.)

첫 번째 방식인 sum_n은 n번의 계산을 하므로 O(n)으로 표기할 수 있다. n이 늘어날 수록 계산의 복잡도도 정비례한다면 이러한 모든 계산 방식의 복잡도는 O(n)이라고 할 수 있다.

두 번째 방식인 sum_n2는 n\*n+1/2의 계산을 하므로 덧셈 한번, 곱셈 한 번, 나눗셈 한 번을 한다. 따라서 O(3)이라고 할 수 있다. 하지만 표기는 O(1)이라고 한다. 왜냐하면 입력 값이 아무리 커져도 계산 시간에는 영향을 주지 않기 때문이다. 이 처럼 입력에 상관없이 계산 복잡도가 일정한 계산은 모두 O(1)로 표기한다. 따라서 빅오 표기법은 어떤 알고리즘의 대략적인 계산 복잡도를 표기해주는 방법이라고 할 수 있다.

### 빅오 표기법의 정의 및 계산

빅오의 정의는 다음과 같다.

_모든 n, n >= n0에 대해 f(n) <= cg(n)인 조건을 만족하는 두 양의 상수 c와 n0이 존재하기만 하면 f(n) = O(g(n))이다._

g(n) = n, c = 4 , f(n) = 3n + 2라고 하면

| n   | 3n+2 | 4n  |
| --- | ---- | --- |
| 1   | 5    | 4   |
| 2   | 8    | 8   |
| 3   | 11   | 12  |
| 4   | 14   | 16  |
| 5   | 17   | 20  |

n=4인 지점부터 3n + 2 <= 4n을 만족하므로 계산 복잡도는 O(n)이 된다.

위 1부터 n의 합 알고리즘을 위 방법 대로 계산해보면

```python
def sum_n(n):
    s = 0
    i = 0
    for i in range(0, n): # n번의 계산
        i = i+1 # 한 번의 덧셈이므로 O(1)에 해당
        s = s + i # 한 번의 덧셈이므로 O(1)에 해당
    return s
```

따라서 복잡도는 간단하게 n이 되고 c=2라고 하면

| n   | n   | 2n  |
| --- | --- | --- |
| 1   | 1   | 2   |

n이 1일 때부터 n <= 2n을 만족하므로 O(n)이라고 할 수 있다.

만약 for문이 두 번 중첩되면 n번의 계산이 두 번 일어나므로 O(n^2)라고 할 수 있다.

## Conclusion

자료구조는 공간과 시간에 대한 효율성을 향상시키기 위한 데이터의 저장 방법이다.  
간단한 계산 함수는 계산 복잡도에서 큰 차이가 없지만 프로그램이 커질 수록 계산 복잡도를 잘 고려하여 프로그래밍을 해야 한다.
