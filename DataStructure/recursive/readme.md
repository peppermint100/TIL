## 팩토리얼

팩토리얼이란 1부터 어떤 수 n까지 연속한 숫자들을 전부 곱한 값을 의미하며 표기는

_n!_ 으로 표기합니다.

1! = 1

2! = 1\*2

3! = 1\*2\*3

_단 0! = 1_

```python
def fac(n):
    s = 1
    for i in range(1, n + 1):
        s = s * i
    return s

print(fac(3))
```

파이썬 코드로는 이렇게 표현 할 수 있습니다.

## 재귀 호출

3! = 3\*2\*1입니다. 그렇다면 n! = n\*(n-1)\*(n-2)...이고 결국 n! = n\*(n-1)!과 같습니다.

이를 파이썬 코드로 나타내면

```python
def fac2(n):
    if(n == 0):
        return 1
    else:
        return n * fac2(n-1)

print(fac2(5))
```

위 코드처럼 함수 자기 자신을 리턴하는 것을 재귀 호출이라 하고 재귀 호출하는 함수를 재귀 함수라 합니다.

## 최대 공약수 구하기

```python
def gcd(a, b):
    k = min(a, b)
    for i in range(k, 1, -1):
        if a % i == 0 and b % i == 0:
            return i
    return 1


print(gcd(10, 5))
```

위와 같이 모듈로 연산(%)을 통해서 최대 공약수를 구할 수 있습니다.

## 유클리드 알고리즘

어떤 수 a와 b의 최대 공약수는 b와 a를 b로 나눈 나머지의 최대 공약수와 같습니다. 그리고 0과 어떤 수 k의 최대공약수는 k입니다. 이 두 가지 성질을 이용하면 다음과 같은 코드로 최대 공약수를 간단하게 구할 수 있습니다.

```python
def gcd2(a, b):
    k = min(a, b)
    if(b == 0):
        return a
    return gcd2(b, a % b)

print(gcd2(10, 5))
```

## 반복문과 재귀함수

반복문과 재귀함수는 어떤 일련의 규칙적인 행동을 계속해서 실행하는 것이 비슷하다. 두 형태 모두

특정 조건에 도달할 때 까지 계속해서 실행되며 만약 조건이 제대로 주어지지 않아서 종료 조건에 도달 하지 않

는 경우 무한 반복을 한다. 단 차이점이라면 반복문에서는 초기화를 계속 해주며 스택 메모리를 사용하지

않는다. 하지만 재귀 함수는 계속해서 자기 자신 함수를 호출하기 때문에 새 메모리를 계속 할당하는 문제가 생긴

다. 하지만 재귀함수는 코드 자체가 간결해지고 가독성이 좋아진다. 일반적으로 모든 프로그램에서는

메모리 효율의 이유로 재귀함수의 사용을 지양하는 것이 맞다.(물론 예외는 존재한다.)
